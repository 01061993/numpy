#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"

#define _MULTIARRAYMODULE
#include <numpy/ndarrayobject.h>

#include "new_iterator.h"


#define NPY_ITER_FLAGS_IDENTPERM 0x001
#define NPY_ITER_FLAGS_HASINDEX  0x002
#define NPY_ITER_FLAGS_HASCOORDS 0x004

/*
 * The data layout of the iterator is fully specified by
 * a triple (itflags, ndim, niter).  These three variables
 * are expected to exist in all functions calling these macros,
 * either as true variables initialized to the correct values
 * from the iterator, or as constants in the case of specialized
 * functions such as the various iternext functions.
 */

/* Size of all the data before the AXISDATA starts */
#define NIT_SIZEOF_BASEDATA() ( \
        /* uint32 itflags AND uint16 ndim AND uint16 niter */ \
        8 + \
        /* npy_intp perm[ndim] */ \
        (NPY_SIZEOF_INTP)*(ndim) + \
        /* PyArray_Descr* dtypes[niter] */ \
        /* npy_intp itemsizes[niter] */ \
        2*(NPY_SIZEOF_INTP)*(niter) \
        )

/* Size of one AXISDATA struct within the iterator */
#define NIT_SIZEOF_AXISDATA() (( \
        /* intp shape */ \
        1 + \
        /* intp coord */ \
        1 + \
        /* intp stride[niter] AND char* ptr[niter] */ \
        2*(niter) + \
        /* intp indexstride AND intp index (when index is provided) */ \
        ((itflags&NPY_ITER_FLAGS_HASINDEX) ? 2 : 0) \
        )*NPY_SIZEOF_INTP ) \

/* Size of the whole iterator */
#define NIT_SIZEOF_ITERATOR() ( \
        NIT_SIZEOF_BASEDATA() + \
        NIT_SIZEOF_AXISDATA()*(ndim) + \
        NPY_SIZEOF_INTP*(ndim) + \
        NPY_SIZEOF_INTP*(niter))

/* Internal-only ITERATOR DATA MEMBER ACCESS */
#define NIT_ITFLAGS(iter) \
        (*((npy_uint32*)(iter)))
#define NIT_NDIM(iter) \
        (*((npy_uint16*)(iter) + 2))
#define NIT_NITER(iter) \
        (*((npy_uint16*)(iter) + 3))
#define NIT_PERM(iter)  ((npy_intp*)( \
        (char*)(iter) + 8))
#define NIT_DTYPES(iter) ((PyArray_Descr**)( \
        (char*)(iter) + 8 + \
        (NPY_SIZEOF_INTP)*(ndim)))
#define NIT_ITEMSIZES(iter) ((npy_intp*)( \
        (char*)(iter) + 8 + \
        (NPY_SIZEOF_INTP)*(ndim) + \
        (NPY_SIZEOF_INTP)*(niter)))
#define NIT_AXISDATA(iter) \
        ((char*)(iter) + NIT_SIZEOF_BASEDATA())
#define NIT_OBJECTS(iter) ((PyObject**)( \
        (char*)(iter) + NIT_SIZEOF_BASEDATA() + \
        (NIT_SIZEOF_AXISDATA())*(ndim)))

/* Internal-only AXISDATA MEMBER ACCESS. */
#define NAD_SHAPE(axisdata) (*((npy_intp*)(axisdata)))
#define NAD_COORD(axisdata) (*((npy_intp*)(axisdata) + 1))
#define NAD_STRIDES(axisdata) ((npy_intp*)(axisdata) + 2)
#define NAD_PTRS(axisdata) \
        ((char**)(axisdata) + 2 + NAD_NSTRIDES())
#define NAD_NSTRIDES() \
        ((niter) + ((itflags&NPY_ITER_FLAGS_HASINDEX) ? 1 : 0))

void* NpyIter_New(PyObject* op, npy_uint32 flags, PyArray_Descr* dtype,
                  int min_depth, int max_depth)
{
    npy_uint32 itflags = NPY_ITER_FLAGS_IDENTPERM;
    npy_intp ndim;
    npy_intp niter = 1;

    npy_intp idim, indexstride, sizeof_axisdata;
    PyArray_Descr* opdtype;
    void* iter = 0;
    char* axisdata = 0;

    /* Currently only work with arrays */
    if (!PyArray_Check(op)) {
        PyErr_SetString(PyExc_ValueError,
                "Can only create an iterator for an array");
        return NULL;
    }

    ndim = PyArray_NDIM(op);
    if ((min_depth >= 0 && ndim < min_depth) ||
            (max_depth >= 0 && ndim > max_depth)) {
        PyErr_Format(PyExc_ValueError,
                "Requested an iterator with %d <= ndim <= %d, "
                "but input object ndim is %d",
                min_depth, max_depth, (int)ndim);
        return NULL;
    }

    /* Get the data type of the array */
    opdtype = PyArray_DESCR(op);
    if (opdtype == NULL) {
        PyErr_SetString(PyExc_ValueError,
                "Input object has no dtype descr");
        return NULL;
    }
    if (dtype != NULL && !PyArray_EquivTypes(opdtype, dtype)) {
        PyErr_SetString(PyExc_ValueError,
                "Don't support automatic dtype conversions yet");
        return NULL;
    }
    /* Take a reference to the dtype for the iterator */
    Py_INCREF(opdtype);

    /* Process the input flags */
    if (flags&(NPY_ITER_C_ORDER_INDEX | NPY_ITER_F_ORDER_INDEX)) {
        if ((flags&(NPY_ITER_C_ORDER_INDEX | NPY_ITER_F_ORDER_INDEX)) ==
                    (NPY_ITER_C_ORDER_INDEX | NPY_ITER_F_ORDER_INDEX)) {
            PyErr_SetString(PyExc_ValueError,
                    "Iterator flags NPY_ITER_C_ORDER_INDEX and "
                    "NPY_ITER_F_ORDER_INDEX cannot both be specified");
            return NULL;
        }
        itflags |= NPY_ITER_FLAGS_HASINDEX;
    }
    if (flags&NPY_ITER_COORDS) {
        /*
         * This flag primarily disables dimension manipulations that
         * would produce a different set of coordinates.
         */
        itflags |= NPY_ITER_FLAGS_HASCOORDS;
    }

    /* Allocate memory for the iterator */
    iter = malloc(NIT_SIZEOF_ITERATOR());

    /* Fill in the base data */
    NIT_ITFLAGS(iter) = itflags;
    NIT_NDIM(iter) = ndim;
    NIT_NITER(iter) = niter;
    NIT_DTYPES(iter)[0] = opdtype;
    NIT_ITEMSIZES(iter)[0] = PyArray_ITEMSIZE(op);

    /* Fill in the axis data (in reverse of C order)*/
    sizeof_axisdata = NIT_SIZEOF_AXISDATA();
    axisdata = NIT_AXISDATA(iter);
    for(idim = ndim-1; idim >= 0; --idim, axisdata += sizeof_axisdata) {
        NAD_SHAPE(axisdata) = PyArray_DIM(op, idim);
        NAD_COORD(axisdata) = 0;
        NAD_STRIDES(axisdata)[0] = PyArray_STRIDE(op, idim);
        NAD_PTRS(axisdata)[0] = PyArray_DATA(op);
    }

    /* If an index was requested, compute the strides for it */
    if (flags&NPY_ITER_C_ORDER_INDEX) {
        indexstride = 1;
        axisdata = NIT_AXISDATA(iter);
        for(idim = 0; idim < ndim; ++idim, axisdata += sizeof_axisdata) {
            NAD_STRIDES(axisdata)[1] = indexstride;
            NAD_PTRS(axisdata)[1] = 0;
            indexstride *= NAD_SHAPE(axisdata);
        }
    } else if (flags&NPY_ITER_F_ORDER_INDEX) {
        indexstride = 1;
        axisdata = NIT_AXISDATA(iter) + (ndim-1)*sizeof_axisdata;
        for(idim = 0; idim < ndim; ++idim, axisdata -= sizeof_axisdata) {
            NAD_STRIDES(axisdata)[1] = indexstride;
            NAD_PTRS(axisdata)[1] = 0;
            indexstride *= NAD_SHAPE(axisdata);
        }
    }

    /*
     * If an iteration order is being forced, apply it, otherwise
     * compute the most cache-friendly order.
     */
    if (flags&(NPY_ITER_FORCE_F_ORDER|NPY_ITER_FORCE_ANY_CONTIGUOUS)) {
        if ((flags&NPY_ITER_FORCE_F_ORDER) ||
                ((flags&NPY_ITER_FORCE_ANY_CONTIGUOUS) && 
                 PyArray_CHKFLAGS(op, NPY_F_CONTIGUOUS))) {
            npy_intp i, temp, size = sizeof_axisdata/NPY_SIZEOF_INTP;
            npy_intp* first = (npy_intp*)NIT_AXISDATA(iter);
            npy_intp* last = first + (ndim-1)*size;
            
            /* This loop reverses the order of the AXISDATA array */
            while (first < last) {
                for(i = 0; i < size; ++i) {
                    temp = first[i];
                    first[i] = last[i];
                    last[i] = temp;
                }
                first += size;
                last -= size;
            }

            /* Store the perm we applied */
            first = NIT_PERM(iter);
            for(i = ndim-1; i >= 0; --i, ++first) {
                *first = i;
            }
            itflags &= ~NPY_ITER_FLAGS_IDENTPERM;
            NIT_ITFLAGS(iter) = itflags;
        }
    } else if (!(flags&NPY_ITER_FORCE_C_ORDER)) {
        /* TODO, for now just say C order */
    }

    /* Fill in the destruction data */
    NIT_OBJECTS(iter)[0] = op;
    Py_INCREF(op);

    return iter;
}

int NpyIter_Deallocate(void* iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    npy_intp i;
    PyArray_Descr **dtypes = NIT_DTYPES(iter);
    PyObject **arrays = NIT_OBJECTS(iter);

    /* Deallocate all the dtypes and objects that were iterated */
    for(i = 0; i < niter; ++i) {
        Py_XDECREF(dtypes[i]);
        Py_XDECREF(arrays[i]);
    }

    /* Deallocate the iterator memory */
    free(iter);

    return NPY_SUCCEED;
}


/* SPECIALIZED iternext functions */

/**begin repeat
 * #const_itflags = 0, NPY_ITER_FLAGS_HASINDEX#
 * #tag_itflags = 0, IND#
 */
/**begin repeat1
 * #const_ndims = 1, 2, 3, 100#
 * #tag_ndims = 1, 2, 3, ANY#
 */
/**begin repeat2
 * #const_niter = 1#
 * #tag_niter = 1#
 */

/* Specialized iternext (@const_itflags@,@const_ndims@,@const_niter@) */
NPY_NO_EXPORT int
npyiter_iternext_itflags@tag_itflags@_dims@tag_ndims@_iters@tag_niter@(
                                                                void *iter)
{
    const npy_uint32 itflags = @const_itflags@;
#if @const_ndims@ < 100
    const npy_intp ndim = @const_ndims@;
#else
    npy_intp idim, ndim = NIT_NDIM(iter);
#endif
    const npy_intp niter = @const_niter@;

    npy_intp istrides, nstrides, sizeof_axisdata;
#if @const_ndims@ > 0
    char* axisdata0;
#endif
#if @const_ndims@ > 1
    char* axisdata1;
#endif
#if @const_ndims@ > 2
    char* axisdata2;
#endif

    nstrides = NAD_NSTRIDES();
    sizeof_axisdata = NIT_SIZEOF_AXISDATA();

    axisdata0 = NIT_AXISDATA(iter);
    /* Increment coordinate 0 */
    NAD_COORD(axisdata0)++;
    /* Increment pointer 0 */
    for (istrides = 0; istrides < nstrides; ++istrides) {
        NAD_PTRS(axisdata0)[istrides] += NAD_STRIDES(axisdata0)[istrides];
    }

#if @const_ndims@ == 1
    /* Finished when the coordinate equals the shape */
    return NAD_COORD(axisdata0) < NAD_SHAPE(axisdata0);
# else

    if (NAD_COORD(axisdata0) < NAD_SHAPE(axisdata0)) {
        return 1;
    }

    axisdata1 = axisdata0 + sizeof_axisdata;
    /* Increment coordinate 1 */
    NAD_COORD(axisdata1)++;
    /* Increment pointer 1 */
    for (istrides = 0; istrides < nstrides; ++istrides) {
        NAD_PTRS(axisdata1)[istrides] += NAD_STRIDES(axisdata1)[istrides];
    }

    if (NAD_COORD(axisdata1) < NAD_SHAPE(axisdata1)) {
        /* Reset the 1st coordinate to 0 */
        NAD_COORD(axisdata0) = 0;
        /* Reset the 1st pointer to the value of the 2nd */
        for (istrides = 0; istrides < nstrides; ++istrides) {
            NAD_PTRS(axisdata0)[istrides] = NAD_PTRS(axisdata1)[istrides];
        }
        return 1;
    }

# if @const_ndims@ == 2
    return 0;
# else
    
    axisdata2 = axisdata1 + sizeof_axisdata;
    /* Increment coordinate 2 */
    NAD_COORD(axisdata2)++;
    /* Increment pointer 2 */
    for (istrides = 0; istrides < nstrides; ++istrides) {
        NAD_PTRS(axisdata2)[istrides] += NAD_STRIDES(axisdata2)[istrides];
    }

    if (NAD_COORD(axisdata2) < NAD_SHAPE(axisdata2)) {
        /* Reset the 1st and 2nd coordinates to 0 */
        NAD_COORD(axisdata0) = 0;
        NAD_COORD(axisdata1) = 0;
        /* Reset the 1st and second pointers to the value of the 3nd */
        for (istrides = 0; istrides < nstrides; ++istrides) {
            NAD_PTRS(axisdata0)[istrides] = NAD_PTRS(axisdata2)[istrides];
            NAD_PTRS(axisdata1)[istrides] = NAD_PTRS(axisdata2)[istrides];
        }
        return 1;
    }

#  if @const_ndims@ == 3
    return 0;
#  else

    for (idim = 3; idim < ndim; ++idim) {
        axisdata2 += sizeof_axisdata;
        /* Increment the coordinate */
        NAD_COORD(axisdata2)++;
        /* Increment the pointer */
        for (istrides = 0; istrides < nstrides; ++istrides) {
            NAD_PTRS(axisdata2)[istrides] += NAD_STRIDES(axisdata2)[istrides];
        }


        if (NAD_COORD(axisdata2) < NAD_SHAPE(axisdata2)) {
            /* Reset the coordinates and pointers of all previous axisdatas */
            axisdata1 = axisdata2;
            do {
                axisdata1 -= sizeof_axisdata;
                /* Reset the coordinate to 0 */
                NAD_COORD(axisdata1) = 0;
                /* Reset the pointer to the updated value */
                for (istrides = 0; istrides < nstrides; ++istrides) {
                    NAD_PTRS(axisdata1)[istrides] =
                                        NAD_PTRS(axisdata2)[istrides];
                }
            } while (axisdata1 != axisdata0);

            return 1;
        }
    }

    return 0;

#  endif /* ndims != 3 */

# endif /* ndims != 2 */
    
#endif /* ndims != 1 */
}

/**end repeat2**/
/**end repeat1**/
/**end repeat**/

/* Returns a specialized iternext function */
NpyIter_IterNext_Fn NpyIter_GetIterNext(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    /*
     * Ignore all the flags that don't affect the iterator memory
     * layout or the iternext function.  Currently only HASINDEX
     * affects them.
     */
    itflags &= NPY_ITER_FLAGS_HASINDEX;

    /* Switch statements let the compiler optimize this most effectively */
    switch (itflags) {
/**begin repeat
 * #const_itflags = 0, NPY_ITER_FLAGS_HASINDEX#
 * #tag_itflags = 0, IND#
 */
        case @const_itflags@:
            switch (ndim) {
/**begin repeat1
 * #const_ndims = 1, 2, 3#
 * #tag_ndims = 1, 2, 3#
 */
                case @const_ndims@:
                    switch (niter) {
/**begin repeat2
 * #const_niter = 1#
 * #tag_niter = 1#
 */
                        case @const_niter@:
                            return &npyiter_iternext_itflags@tag_itflags@_dims@tag_ndims@_iters@tag_niter@;
/**end repeat2**/
                    }
/**end repeat1**/
                default:
                    switch (niter) {
/**begin repeat1
 * #const_niter = 1#
 * #tag_niter = 1#
 */
                        case @const_niter@:
                            return &npyiter_iternext_itflags@tag_itflags@_dimsANY_iters@tag_niter@;
/**end repeat1**/
                    }
            }
/**end repeat**/
    }
    /* Return an unspecialized iternext function */
    return NULL; /* TODO: return generic version */
}


/* SPECIALIZED getcoord functions */

/**begin repeat
 * #const_itflags = 0,
 *    NPY_ITER_FLAGS_HASINDEX,
 *    NPY_ITER_FLAGS_IDENTPERM,
 *    NPY_ITER_FLAGS_HASINDEX|NPY_ITER_FLAGS_IDENTPERM#
 * #tag_itflags = 0, IND, IDP, INDuIDP#
 */
NPY_NO_EXPORT void
npyiter_getcoord_itflags@tag_itflags@(void *iter, npy_intp *outcoord)
{
    const npy_uint32 itflags = @const_itflags@;
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    npy_intp idim, sizeof_axisdata;
    char* axisdata;
#if !((@const_itflags@)&NPY_ITER_FLAGS_IDENTPERM)
    npy_intp* perm = NIT_PERM(iter);
#endif

    outcoord += ndim-1;
    axisdata = NIT_AXISDATA(iter);
    sizeof_axisdata = NIT_SIZEOF_AXISDATA();
#if ((@const_itflags@)&NPY_ITER_FLAGS_IDENTPERM)
    for(idim = 0; idim < ndim; ++idim, --outcoord,
                                    axisdata += sizeof_axisdata) {
        *outcoord = NAD_COORD(axisdata);
    }
#else
    for(idim = 0; idim < ndim; ++idim, --outcoord) {
        *outcoord = NAD_COORD(axisdata + sizeof_axisdata*perm[idim]);
    }
#endif /* not ident perm */
}
/**end repeat**/

/* Returns a specialized getcoord function */
NpyIter_GetCoords_Fn NpyIter_GetGetCoords(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);

    if (!(itflags&NPY_ITER_FLAGS_HASCOORDS)) {
        PyErr_SetString(PyExc_ValueError,
                "Cannot get a GetCoords function for an iterator "
                "that doesn't track coordinates.");
        return NULL;
    }

    itflags &= ~NPY_ITER_FLAGS_HASCOORDS;
    
    switch (itflags) {
/**begin repeat
 * #const_itflags = 0,
 *    NPY_ITER_FLAGS_HASINDEX,
 *    NPY_ITER_FLAGS_IDENTPERM,
 *    NPY_ITER_FLAGS_HASINDEX|NPY_ITER_FLAGS_IDENTPERM#
 * #tag_itflags = 0, IND, IDP, INDuIDP#
 */
        case @const_itflags@:
            return npyiter_getcoord_itflags@tag_itflags@;
/**end repeat**/
    }
    return NULL; /* TODO: return generic version */

}

npy_intp NpyIter_GetNDim(void *iter)
{
    return NIT_NDIM(iter);
}

char **NpyIter_GetDataPtrArray(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    char* axisdata = NIT_AXISDATA(iter);

    return NAD_PTRS(axisdata);
}

npy_intp *NpyIter_GetIndexPtr(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    char* axisdata = NIT_AXISDATA(iter);

    if (itflags&NPY_ITER_FLAGS_HASINDEX) {
        /* The index is just after the data pointers */
        return (npy_intp*)NAD_PTRS(axisdata) + niter;
    } else {
        return NULL;
    }
}


npy_intp *NpyIter_GetItemSizeArray(void *iter)
{
    /*npy_uint32 itflags = NIT_ITFLAGS(iter);*/
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);
    
    return NIT_ITEMSIZES(iter);
}

