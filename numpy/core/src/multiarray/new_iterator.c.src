#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"

#define _MULTIARRAYMODULE
#include <numpy/ndarrayobject.h>

#include "new_iterator.h"


#define NPY_ITER_FLAGS_HASPERM   0x001
#define NPY_ITER_FLAGS_HASINDEX  0x002
#define NPY_ITER_FLAGS_HASCOORDS 0x004

/*
 * The data layout of the iterator is fully specified by
 * a triple (itflags, ndim, niter).  These three variables
 * are expected to exist in all functions calling these macros,
 * either as true variables initialized to the correct values
 * from the iterator, or as constants in the case of specialized
 * functions such as the various iternext functions.
 */

/* Size of all the data before the AXISDATA starts */
#define NIT_SIZEOF_BASEDATA() ( \
        /* uint32 itflags AND uint16 ndim AND uint16 niter */ \
        8 + \
        /* PyArray_Descr* dtypes[niter] */ \
        /* npy_intp itemsizes[niter] */ \
        2*(NPY_SIZEOF_INTP)*(niter) \
        )

/* Size of one AXISDATA struct within the iterator */
#define NIT_SIZEOF_AXISDATA() (( \
        /* intp shape */ \
        1 + \
        /* intp coord */ \
        1 + \
        /* intp stride[niter] AND char* ptr[niter] */ \
        2*(niter) + \
        /* intp indexstride AND intp index (when index is provided) */ \
        ((itflags&NPY_ITER_FLAGS_HASINDEX) ? 2 : 0) \
        )*NPY_SIZEOF_INTP ) \

/* Size of the whole iterator */
#define NIT_SIZEOF_ITERATOR() ( \
        NIT_SIZEOF_BASEDATA() + \
        NIT_SIZEOF_AXISDATA()*(ndim) + \
        NPY_SIZEOF_INTP*(ndim) + \
        NPY_SIZEOF_INTP*(niter))

/* Internal-only ITERATOR DATA MEMBER ACCESS */
#define NIT_ITFLAGS(iter) \
        (*((npy_uint32*)(iter)))
#define NIT_NDIM(iter) \
        (*((npy_uint16*)(iter) + 2))
#define NIT_NITER(iter) \
        (*((npy_uint16*)(iter) + 3))
#define NIT_DTYPES(iter) \
        ((PyArray_Descr**)((char*)(iter) + 8))
#define NIT_ITEMSIZES(iter) \
        ((npy_intp*)((char*)(iter) + 8 + NPY_SIZEOF_INTP*(niter)))
#define NIT_AXISDATA(iter) \
        ((char*)(iter) + NIT_SIZEOF_BASEDATA())
#define NIT_PERM(iter)  ((npy_intp*)( \
        (char*)(iter) + NIT_SIZEOF_BASEDATA() + \
        NIT_SIZEOF_AXISDATA() *(ndim))
#define NIT_OBJECTS(iter) ((PyObject**)( \
        (char*)(iter) + NIT_SIZEOF_BASEDATA() + \
        (NIT_SIZEOF_AXISDATA() + \
         (((itflags)&NPY_ITER_FLAGS_HASPERM) ? NPY_SIZEOF_INTP : 0) \
        )*(ndim)))

/* Internal-only AXISDATA MEMBER ACCESS. */
#define NAD_SHAPE(axisdata) (*((npy_intp*)(axisdata)))
#define NAD_COORD(axisdata) (*((npy_intp*)(axisdata) + 1))
#define NAD_STRIDES(axisdata) ((npy_intp*)(axisdata) + 2)
#define NAD_PTRS(axisdata) \
        ((char**)(axisdata) + 2 + NAD_NSTRIDES())
#define NAD_NSTRIDES() \
        ((niter) + ((itflags&NPY_ITER_FLAGS_HASINDEX) ? 1 : 0))

void* NpyIter_New(PyObject* op, npy_uint32 flags, PyArray_Descr* dtype,
                  int min_depth, int max_depth)
{
    npy_uint32 itflags = 0;
    npy_intp idim, ndim, niter = 1, indexstride, sizeof_axisdata;
    PyArray_Descr* opdtype;
    void* iter = 0;
    char* axisdata = 0;

    /* Currently only work with arrays */
    if (!PyArray_Check(op)) {
        PyErr_SetString(PyExc_ValueError,
                "Can only create an iterator for an array");
        return NULL;
    }

    ndim = PyArray_NDIM(op);
    if ((min_depth >= 0 && ndim < min_depth) ||
            (max_depth >= 0 && ndim > max_depth)) {
        PyErr_Format(PyExc_ValueError,
                "Requested an iterator with %d <= ndim <= %d, "
                "but input object ndim is %d",
                min_depth, max_depth, (int)ndim);
        return NULL;
    }

    /* Get the data type of the array */
    opdtype = PyArray_DESCR(op);
    if (opdtype == NULL) {
        PyErr_SetString(PyExc_ValueError,
                "Input object has no dtype descr");
        return NULL;
    }
    if (dtype != NULL && !PyArray_EquivTypes(opdtype, dtype)) {
        PyErr_SetString(PyExc_ValueError,
                "Don't support automatic dtype conversions yet");
        return NULL;
    }
    /* Take a reference to the dtype for the iterator */
    Py_INCREF(opdtype);

    /* Process the input flags */
    if (flags&(NPY_ITER_CORDER_INDEX | NPY_ITER_FORTRANORDER_INDEX)) {
        if ((flags&(NPY_ITER_CORDER_INDEX | NPY_ITER_FORTRANORDER_INDEX)) ==
                    (NPY_ITER_CORDER_INDEX | NPY_ITER_FORTRANORDER_INDEX)) {
            PyErr_SetString(PyExc_ValueError,
                    "Iterator flags NPY_ITER_CORDER_INDEX and "
                    "NPY_ITER_FORTRANORDER_INDEX cannot both be specified");
            return NULL;
        }
        itflags |= NPY_ITER_FLAGS_HASINDEX;
    }
    if (flags&NPY_ITER_COORDS) {
        /*
         * This flag primarily disables dimension manipulations that
         * would produce a different set of coordinates.
         */
        itflags |= NPY_ITER_FLAGS_HASCOORDS;
    }

    /* Allocate memory for the iterator */
    iter = malloc(NIT_SIZEOF_ITERATOR());

    /* Fill in the base data */
    NIT_ITFLAGS(iter) = itflags;
    NIT_NDIM(iter) = ndim;
    NIT_NITER(iter) = niter;
    NIT_DTYPES(iter)[0] = opdtype;
    NIT_ITEMSIZES(iter)[0] = PyArray_ITEMSIZE(op);

    /* Fill in the axis data (in reverse of C order)*/
    sizeof_axisdata = NIT_SIZEOF_AXISDATA();
    axisdata = NIT_AXISDATA(iter);
    for(idim = ndim-1; idim >= 0; --idim, axisdata += sizeof_axisdata) {
        NAD_SHAPE(axisdata) = PyArray_DIM(op, idim);
        NAD_COORD(axisdata) = 0;
        NAD_STRIDES(axisdata)[0] = PyArray_STRIDE(op, idim);
        NAD_PTRS(axisdata)[0] = PyArray_DATA(op);
    }

    /* If an index was requested, compute the strides for it */
    if (flags&NPY_ITER_CORDER_INDEX) {
        indexstride = 1;
        axisdata = NIT_AXISDATA(iter);
        for(idim = 0; idim < ndim; ++idim, axisdata += sizeof_axisdata) {
            NAD_STRIDES(axisdata)[1] = indexstride;
            NAD_PTRS(axisdata)[1] = 0;
            indexstride *= NAD_SHAPE(axisdata);
        }
    } else if (flags&NPY_ITER_FORTRANORDER_INDEX) {
        indexstride = 1;
        axisdata = NIT_AXISDATA(iter) + (ndim-1)*sizeof_axisdata;
        for(idim = 0; idim < ndim; ++idim, axisdata -= sizeof_axisdata) {
            NAD_STRIDES(axisdata)[1] = indexstride;
            NAD_PTRS(axisdata)[1] = 0;
            indexstride *= NAD_SHAPE(axisdata);
        }
    }

    /* Fill in the destruction data */
    NIT_OBJECTS(iter)[0] = op;
    Py_INCREF(op);

    return iter;
}

int NpyIter_Deallocate(void* iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    npy_intp i;
    PyArray_Descr **dtypes = NIT_DTYPES(iter);
    PyObject **arrays = NIT_OBJECTS(iter);

    /* Deallocate all the dtypes and objects that were iterated */
    for(i = 0; i < niter; ++i) {
        Py_XDECREF(dtypes[i]);
        Py_XDECREF(arrays[i]);
    }

    /* Deallocate the iterator memory */
    free(iter);

    return NPY_SUCCEED;
}


/* SPECIALIZED iternext functions */

/**begin repeat
 * #const_itflags = 0, NPY_ITER_FLAGS_HASINDEX, NPY_ITER_FLAGS_HASCOORDS,
 *                  NPY_ITER_FLAGS_HASINDEX|NPY_ITER_FLAGS_HASCOORDS #
 * #tag_itflags = 0, IND, COORD, INDwCOORD#
 */
/**begin repeat1
 * #const_ndims = 1, 2#
 * #tag_ndims = 1, 2#
 */
/**begin repeat2
 * #const_niter = 1#
 * #tag_niter = 1#
 */

/* Specialized iternext (@const_itflags@,@const_ndims@,@const_niter@) */
NPY_NO_EXPORT int
npyiter_iternext_itflags@tag_itflags@_dims@tag_ndims@_iters@tag_niter@(
                                                                void *iter)
{
    const npy_uint32 itflags = @const_itflags@;
    const npy_intp ndim = @const_ndims@;
    const npy_intp niter = @const_niter@;

    npy_intp istrides, nstrides;
#if @const_ndims@ > 0
    char* axisdata0;
#endif
#if @const_ndims@ > 1
    char* axisdata1;
#endif
#if @const_ndims@ > 2
    char* axisdata2;
#endif

    nstrides = NAD_NSTRIDES();

    axisdata0 = NIT_AXISDATA(iter);
    /* Increment coordinate 0 */
    NAD_COORD(axisdata0)++;
    /* Increment pointer 0 */
    for (istrides = 0; istrides < nstrides; ++istrides) {
        NAD_PTRS(axisdata0)[istrides] += NAD_STRIDES(axisdata0)[istrides];
    }

#if @const_ndims@ == 1
    /* Finished when the coordinate equals the shape */
    return NAD_COORD(axisdata0) < NAD_SHAPE(axisdata0);
# else

    if (NAD_COORD(axisdata0) < NAD_SHAPE(axisdata0)) {
        return 1;
    }

    axisdata1 = axisdata0 + NIT_SIZEOF_AXISDATA();
    /* Increment coordinate 1 */
    NAD_COORD(axisdata1)++;
    /* Increment pointer 1 */
    for (istrides = 0; istrides < nstrides; ++istrides) {
        NAD_PTRS(axisdata1)[istrides] += NAD_STRIDES(axisdata1)[istrides];
    }

# if @const_ndims@ == 2
    if (NAD_COORD(axisdata1) < NAD_SHAPE(axisdata1)) {
        /* Reset the 1st coordinate to 0 */
        NAD_COORD(axisdata0) = 0;
        /* Reset the 1st pointer to the value of the 2nd */
        for (istrides = 0; istrides < nstrides; ++istrides) {
            NAD_PTRS(axisdata0)[istrides] = NAD_PTRS(axisdata1)[istrides];
        }
        return 1;
    } else {
        return 0;
    }
# else
    return 0;
# endif /* ndims != 2 */
    
#endif /* ndims != 1 */
}

/**end repeat2**/
/**end repeat1**/
/**end repeat**/

/* Returns a specialized iternext function */
NpyIter_IterNext_Fn NpyIter_GetIterNext(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    /* Switch statements let the compiler optimize this most effectively */
    switch (itflags) {
/**begin repeat
 * #const_itflags = 0, NPY_ITER_FLAGS_HASINDEX, NPY_ITER_FLAGS_HASCOORDS,
 *                  NPY_ITER_FLAGS_HASINDEX|NPY_ITER_FLAGS_HASCOORDS #
 * #tag_itflags = 0, IND, COORD, INDwCOORD#
 */
        case @const_itflags@:
            switch (ndim) {
/**begin repeat1
 * #const_ndims = 1, 2#
 * #tag_ndims = 1, 2#
 */
                case @const_ndims@:
                    switch (niter) {
/**begin repeat2
 * #const_niter = 1#
 * #tag_niter = 1#
 */
                        case @const_niter@:
                            return &npyiter_iternext_itflags@tag_itflags@_dims@tag_ndims@_iters@tag_niter@;
/**end repeat2**/
                    }
/**end repeat1**/
            }
/**end repeat**/
    }
    /* Return an unspecialized iternext function */
    return NULL; /* TODO: return generic version */
}


/* SPECIALIZED getcoord functions */

/**begin repeat
 * #const_itflags = 0, NPY_ITER_FLAGS_HASINDEX, NPY_ITER_FLAGS_HASCOORDS,
 *                  NPY_ITER_FLAGS_HASINDEX|NPY_ITER_FLAGS_HASCOORDS #
 * #tag_itflags = 0, IND, COORD, INDwCOORD#
 */
NPY_NO_EXPORT void
npyiter_getcoord_itflags@tag_itflags@(void *iter, npy_intp *outcoord)
{
    const npy_uint32 itflags = @const_itflags@;
    npy_intp ndim = NIT_NDIM(iter);
    npy_intp niter = NIT_NITER(iter);

    npy_intp idim, sizeof_axisdata;
    char* axisdata;

    outcoord += ndim-1;
    axisdata = NIT_AXISDATA(iter);
    sizeof_axisdata = NIT_SIZEOF_AXISDATA();
    for(idim = 0; idim < ndim; ++idim, --outcoord,
                                    axisdata += sizeof_axisdata) {
        *outcoord = NAD_COORD(axisdata);
    }
}
/**end repeat**/

/* Returns a specialized getcoord function */
NpyIter_GetCoords_Fn NpyIter_GetGetCoords(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    
    switch (itflags) {
/**begin repeat
 * #const_itflags = 0, NPY_ITER_FLAGS_HASINDEX, NPY_ITER_FLAGS_HASCOORDS,
 *                  NPY_ITER_FLAGS_HASINDEX|NPY_ITER_FLAGS_HASCOORDS #
 * #tag_itflags = 0, IND, COORD, INDwCOORD#
 */
        case @const_itflags@:
            return npyiter_getcoord_itflags@tag_itflags@;
/**end repeat**/
    }
    return NULL; /* TODO: return generic version */

}

npy_intp NpyIter_GetNDim(void *iter)
{
    return NIT_NDIM(iter);
}

char **NpyIter_GetDataPtrArray(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    /*npy_intp ndim = NIT_NDIM(iter);*/
    npy_intp niter = NIT_NITER(iter);

    char* axisdata = NIT_AXISDATA(iter);

    return NAD_PTRS(axisdata);
}

npy_intp *NpyIter_GetIndexPtr(void *iter)
{
    npy_uint32 itflags = NIT_ITFLAGS(iter);
    /*npy_intp ndim = NIT_NDIM(iter);*/
    npy_intp niter = NIT_NITER(iter);

    char* axisdata = NIT_AXISDATA(iter);

    if (itflags&NPY_ITER_FLAGS_HASINDEX) {
        /* The index is just after the data pointers */
        return (npy_intp*)NAD_PTRS(axisdata) + niter;
    } else {
        return NULL;
    }
}


npy_intp *NpyIter_GetItemSizeArray(void *iter)
{
    /*npy_uint32 itflags = NIT_ITFLAGS(iter);*/
    /*npy_intp ndim = NIT_NDIM(iter);*/
    npy_intp niter = NIT_NITER(iter);
    
    return NIT_ITEMSIZES(iter);
}

