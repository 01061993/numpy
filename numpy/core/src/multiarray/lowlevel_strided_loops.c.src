/*
 * This file contains low-level loops for copying and byte-swapping
 * strided data.
 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"

#define _MULTIARRAYMODULE
#include <numpy/ndarrayobject.h>
#include <numpy/ufuncobject.h>
#include <numpy/npy_cpu.h>

#include "lowlevel_strided_loops.h"

/* x86 platform works with unaligned reads and writes */
#if (defined(NPY_CPU_X86) || defined(NPY_CPU_AMD64))
#  define NPY_USE_UNALIGNED_ACCESS 1
#else
#  define NPY_USE_UNALIGNED_ACCESS 0
#endif

#define _NPY_NOP1(x) (x)
#define _NPY_NOP2(x) (x)
#define _NPY_NOP4(x) (x)
#define _NPY_NOP8(x) (x)

#define _NPY_SWAP2(x) (((((npy_uint16)x)&0xffu) << 8) | \
                       (((npy_uint16)x) >> 8))

#define _NPY_SWAP4(x) (((((npy_uint32)x)&0xffu) << 24) | \
                       ((((npy_uint32)x)&0xff00u) << 8) | \
                       ((((npy_uint32)x)&0xff0000u) >> 8) | \
                       (((npy_uint32)x) >> 24))

#define _NPY_SWAP_PAIR4(x) (((((npy_uint32)x)&0xffu) << 8) | \
                       ((((npy_uint32)x)&0xff00u) >> 8) | \
                       ((((npy_uint32)x)&0xff0000u) << 8) | \
                       ((((npy_uint32)x)&0xff000000u) >> 8))

#define _NPY_SWAP8(x) (((((npy_uint64)x)&0xffu) << 56) | \
                       ((((npy_uint64)x)&0xff00u) << 40) | \
                       ((((npy_uint64)x)&0xff0000u) << 24) | \
                       ((((npy_uint64)x)&0xff000000u) << 8) | \
                       ((((npy_uint64)x)&0xff00000000u) >> 8) | \
                       ((((npy_uint64)x)&0xff0000000000u) >> 24) | \
                       ((((npy_uint64)x)&0xff000000000000u) >> 40) | \
                       (((npy_uint64)x) >> 56))

#define _NPY_SWAP_PAIR8(x) (((((npy_uint64)x)&0xffu) << 24) | \
                       ((((npy_uint64)x)&0xff00u) << 8) | \
                       ((((npy_uint64)x)&0xff0000u) >> 8) | \
                       ((((npy_uint64)x)&0xff000000u) >> 24) | \
                       ((((npy_uint64)x)&0xff00000000u) << 24) | \
                       ((((npy_uint64)x)&0xff0000000000u) << 8) | \
                       ((((npy_uint64)x)&0xff000000000000u) >> 8) | \
                       ((((npy_uint64)x)&0xff00000000000000u) >> 24))

#define _NPY_SWAP_INPLACE2(x) { \
        char a = (x)[0]; (x)[0] = (x)[1]; (x)[1] = a; \
        }

#define _NPY_SWAP_INPLACE4(x) { \
        char a = (x)[0]; (x)[0] = (x)[3]; (x)[3] = a; \
        a = (x)[1]; (x)[1] = (x)[2]; (x)[2] = a; \
        }

#define _NPY_SWAP_INPLACE8(x) { \
        char a = (x)[0]; (x)[0] = (x)[7]; (x)[7] = a; \
        a = (x)[1]; (x)[1] = (x)[6]; (x)[6] = a; \
        a = (x)[2]; (x)[2] = (x)[5]; (x)[5] = a; \
        a = (x)[3]; (x)[3] = (x)[4]; (x)[4] = a; \
        }

#define _NPY_SWAP_INPLACE16(x) { \
        char a = (x)[0]; (x)[0] = (x)[15]; (x)[15] = a; \
        a = (x)[1]; (x)[1] = (x)[14]; (x)[14] = a; \
        a = (x)[2]; (x)[2] = (x)[13]; (x)[13] = a; \
        a = (x)[3]; (x)[3] = (x)[12]; (x)[12] = a; \
        a = (x)[4]; (x)[4] = (x)[11]; (x)[11] = a; \
        a = (x)[5]; (x)[5] = (x)[10]; (x)[10] = a; \
        a = (x)[6]; (x)[6] = (x)[9]; (x)[9] = a; \
        a = (x)[7]; (x)[7] = (x)[8]; (x)[8] = a; \
        }

/************* STRIDED COPYING/SWAPPING SPECIALIZED FUNCTIONS *************/

/**begin repeat
 * #elsize = 1, 2, 4, 8, 16#
 * #elsize_half = 0, 1, 2, 4, 8#
 * #type = npy_uint8, npy_uint16, npy_uint32, npy_uint64, npy_uint128#
 */
/**begin repeat1
 * #oper = strided_to_strided, strided_to_contig,
 *         contig_to_strided, contig_to_contig#
 * #src_contig = 0, 0, 1 ,1#
 * #dst_contig = 0, 1, 0 ,1#
 */
/**begin repeat2
 * #swap = _NPY_NOP, _NPY_NOP, _NPY_SWAP_INPLACE, _NPY_SWAP,
 *         _NPY_SWAP_INPLACE, _NPY_SWAP_PAIR#
 * #prefix = , _aligned, _swap, _aligned_swap, _swap_pair, _aligned_swap_pair#
 * #is_aligned = 0, 1, 0, 1, 0, 1#
 * #minelsize = 1, 1, 2, 2, 4, 4#
 * #is_swap = 0, 0, 1, 1, 2, 2#
 */

#if (@elsize@ >= @minelsize@) && \
    (@elsize@ > 1 || @is_aligned@) && \
    (!NPY_USE_UNALIGNED_ACCESS || @is_aligned@)


#if @is_swap@ || @src_contig@ == 0 || @dst_contig@ == 0
static void
@prefix@_@oper@_size@elsize@(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp NPY_UNUSED(src_itemsize),
                        void *NPY_UNUSED(data))
{
    /*printf("fn @prefix@_@oper@_size@elsize@\n");*/
    while (N > 0) {
#if @is_aligned@

        /* aligned copy and swap */
#  if @elsize@ != 16
        (*((@type@ *)dst)) = @swap@@elsize@(*((@type@ *)src));
#  else
#    if @is_swap@ == 0
        (*((npy_uint64 *)dst)) = (*((npy_uint64 *)src));
        (*((npy_uint64 *)dst + 1)) = (*((npy_uint64 *)src + 1));
#    elif @is_swap@ == 1
        (*((npy_uint64 *)dst)) = _NPY_SWAP8(*((npy_uint64 *)src + 1));
        (*((npy_uint64 *)dst + 1)) = _NPY_SWAP8(*((npy_uint64 *)src));
#    elif @is_swap@ == 2
        (*((npy_uint64 *)dst)) = _NPY_SWAP8(*((npy_uint64 *)src));
        (*((npy_uint64 *)dst + 1)) = _NPY_SWAP8(*((npy_uint64 *)src + 1));
#    endif
#  endif

#else

        /* unaligned copy and swap */
        memcpy(dst, src, @elsize@);
#  if @is_swap@ == 1
        @swap@@elsize@(dst);
#  elif @is_swap@ == 2
        @swap@@elsize_half@(dst);
        @swap@@elsize_half@(dst + @elsize_half@);
#  endif

#endif

#if @dst_contig@
        dst += @elsize@;
#else
        dst += dst_stride;
#endif

#if @src_contig@
        src += @elsize@;
#else
        src += src_stride;
#endif

        --N;
    }
}
#endif


/* specialized copy and swap for source stride 0 */
#if (@src_contig@ == 0) && @is_aligned@
static void
@prefix@_@oper@_size@elsize@_srcstride0(char *dst,
                        npy_intp dst_stride,
                        char *src, npy_intp NPY_UNUSED(src_stride),
                        npy_intp N, npy_intp NPY_UNUSED(src_itemsize),
                        void *NPY_UNUSED(data))
{
#if @elsize@ != 16
    @type@ temp = @swap@@elsize@(*((@type@ *)src));
#else
    npy_uint64 temp0, temp1;
#    if @is_swap@ == 0
        temp0 = (*((npy_uint64 *)src));
        temp1 = (*((npy_uint64 *)src + 1));
#    elif @is_swap@ == 1
        temp0 = _NPY_SWAP8(*((npy_uint64 *)src + 1));
        temp1 = _NPY_SWAP8(*((npy_uint64 *)src));
#    elif @is_swap@ == 2
        temp0 = _NPY_SWAP8(*((npy_uint64 *)src));
        temp1 = _NPY_SWAP8(*((npy_uint64 *)src + 1));
#    endif
#endif
    while (N > 0) {
#if @elsize@ != 16
        *((@type@ *)dst) = temp;
#else
        *((npy_uint64 *)dst) = temp0;
        *((npy_uint64 *)dst + 1) = temp1;
#endif
#if @dst_contig@
        dst += @elsize@;
#else
        dst += dst_stride;
#endif
        --N;
    }
}
#endif

#endif/* @elsize@ >= @minelsize@ */

/**end repeat2**/
/**end repeat1**/
/**end repeat**/

static void
_strided_to_strided(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *NPY_UNUSED(data))
{
    while (N > 0) {
        memcpy(dst, src, src_itemsize);
        dst += dst_stride;
        src += src_stride;
        --N;
    }
}

static void
_swap_strided_to_strided(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *NPY_UNUSED(data))
{
    char *a, *b, c;

    while (N > 0) {
        memcpy(dst, src, src_itemsize);
        /* general in-place swap */
        a = dst;
        b = dst + src_itemsize - 1;
        while (a < b) {
            c = *a;
            *a = *b;
            *b = c;
            ++a; --b;
        }
        dst += dst_stride;
        src += src_stride;
        --N;
    }
}

static void
_swap_pair_strided_to_strided(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *NPY_UNUSED(data))
{
    char *a, *b, c;
    npy_intp itemsize_half = src_itemsize / 2;

    while (N > 0) {
        memcpy(dst, src, src_itemsize);
        /* general in-place swap */
        a = dst;
        b = dst + itemsize_half - 1;
        while (a < b) {
            c = *a;
            *a = *b;
            *b = c;
            ++a; --b;
        }
        /* general in-place swap */
        a = dst + itemsize_half;
        b = dst + 2*itemsize_half - 1;
        while (a < b) {
            c = *a;
            *a = *b;
            *b = c;
            ++a; --b;
        }
        dst += dst_stride;
        src += src_stride;
        --N;
    }
}

static void
_strided_to_contig(char *dst, npy_intp NPY_UNUSED(dst_stride),
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *NPY_UNUSED(data))
{
    while (N > 0) {
        memcpy(dst, src, src_itemsize);
        dst += src_itemsize;
        src += src_stride;
        --N;
    }
}

static void
_contig_to_strided(char *dst, npy_intp dst_stride,
                        char *src, npy_intp NPY_UNUSED(src_stride),
                        npy_intp N, npy_intp src_itemsize,
                        void *NPY_UNUSED(data))
{
    while (N > 0) {
        memcpy(dst, src, src_itemsize);
        dst += dst_stride;
        src += src_itemsize;
        --N;
    }
}

static void
_contig_to_contig(char *dst, npy_intp NPY_UNUSED(dst_stride),
                        char *src, npy_intp NPY_UNUSED(src_stride),
                        npy_intp N, npy_intp src_itemsize,
                        void *NPY_UNUSED(data))
{
    memcpy(dst, src, src_itemsize*N);
}


NPY_NO_EXPORT PyArray_StridedTransferFn
PyArray_GetStridedCopyFn(npy_intp aligned, npy_intp src_stride,
                         npy_intp dst_stride, npy_intp itemsize)
{
/*
 * Skip the "unaligned" versions on CPUs which support unaligned
 * memory accesses.
 */
#if !NPY_USE_UNALIGNED_ACCESS
    if (aligned) {
#endif/*!NPY_USE_UNALIGNED_ACCESS*/

        /* contiguous dst */
        if (itemsize != 0 && dst_stride == itemsize) {
            /* constant src */
            if (src_stride == 0) {
                switch (itemsize) {
/**begin repeat
 * #elsize = 1, 2, 4, 8, 16#
 */
                    case @elsize@:
                        return
                          &_aligned_strided_to_contig_size@elsize@_srcstride0;
/**end repeat**/
                }
            }
            /* contiguous src */
            else if (src_stride == itemsize) {
                return &_contig_to_contig;
            }
            /* general src */
            else {
                switch (itemsize) {
/**begin repeat
 * #elsize = 1, 2, 4, 8, 16#
 */
                    case @elsize@:
                        return &_aligned_strided_to_contig_size@elsize@;
/**end repeat**/
                }
            }

            return &_strided_to_contig;
        }
        /* general dst */
        else {
            /* constant src */
            if (src_stride == 0) {
                switch (itemsize) {
/**begin repeat
 * #elsize = 1, 2, 4, 8, 16#
 */
                    case @elsize@:
                        return
                          &_aligned_strided_to_strided_size@elsize@_srcstride0;
/**end repeat**/
                }
            }
            /* contiguous src */
            else if (src_stride == itemsize) {
                switch (itemsize) {
/**begin repeat
 * #elsize = 1, 2, 4, 8, 16#
 */
                    case @elsize@:
                        return &_aligned_contig_to_strided_size@elsize@;
/**end repeat**/
                }

                return &_contig_to_strided;
            }
            else {
                switch (itemsize) {
/**begin repeat
 * #elsize = 1, 2, 4, 8, 16#
 */
                    case @elsize@:
                        return &_aligned_strided_to_strided_size@elsize@;
/**end repeat**/
                }
            }
        }

#if !NPY_USE_UNALIGNED_ACCESS
    }
    else {
        /* contiguous dst */
        if (itemsize != 0 && dst_stride == itemsize) {
            /* contiguous src */
            if (itemsize != 0 && src_stride == itemsize) {
                return &_contig_to_contig;
            }
            /* general src */
            else {
                switch (itemsize) {
                    case 1:
                        return &_aligned_strided_to_contig_size1;
/**begin repeat
 * #elsize = 2, 4, 8, 16#
 */
                    case @elsize@:
                        return &_strided_to_contig_size@elsize@;
/**end repeat**/
                }
            }

            return &_strided_to_contig;
        }
        /* general dst */
        else {
            /* contiguous src */
            if (itemsize != 0 && src_stride == itemsize) {
                switch (itemsize) {
                    case 1:
                        return &_aligned_contig_to_strided_size1;
/**begin repeat
 * #elsize = 2, 4, 8, 16#
 */
                    case @elsize@:
                        return &_contig_to_strided_size@elsize@;
/**end repeat**/
                }

                return &_contig_to_strided;
            }
            /* general src */
            else {
                switch (itemsize) {
                    case 1:
                        return &_aligned_strided_to_strided_size1;
/**begin repeat
 * #elsize = 2, 4, 8, 16#
 */
                    case @elsize@:
                        return &_strided_to_strided_size@elsize@;
/**end repeat**/
                }
            }
        }
    }
#endif/*!NPY_USE_UNALIGNED_ACCESS*/

    return &_strided_to_strided;
}

/*
 * PyArray_GetStridedCopySwapFn and PyArray_GetStridedCopySwapPairFn are
 * nearly identical, so can do a repeat for them.
 */
/**begin repeat
 * #function = PyArray_GetStridedCopySwapFn, PyArray_GetStridedCopySwapPairFn#
 * #tag = , _pair#
 * #not_pair = 1, 0#
 */

NPY_NO_EXPORT PyArray_StridedTransferFn
@function@(npy_intp aligned, npy_intp src_stride,
                             npy_intp dst_stride, npy_intp itemsize)
{
/*
 * Skip the "unaligned" versions on CPUs which support unaligned
 * memory accesses.
 */
#if !NPY_USE_UNALIGNED_ACCESS
    if (aligned) {
#endif/*!NPY_USE_UNALIGNED_ACCESS*/

        /* contiguous dst */
        if (itemsize != 0 && dst_stride == itemsize) {
            /* constant src */
            if (src_stride == 0) {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return
                 &_aligned_swap@tag@_strided_to_contig_size@elsize@_srcstride0;
#endif
/**end repeat1**/
                }
            }
            /* contiguous src */
            else if (src_stride == itemsize) {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_aligned_swap@tag@_contig_to_contig_size@elsize@;
#endif
/**end repeat1**/
                }
            }
            /* general src */
            else {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_aligned_swap@tag@_strided_to_contig_size@elsize@;
#endif
/**end repeat1**/
                }
            }
        }
        /* general dst */
        else {
            /* constant src */
            if (src_stride == 0) {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return
                &_aligned_swap@tag@_strided_to_strided_size@elsize@_srcstride0;
#endif
/**end repeat1**/
                }
            }
            /* contiguous src */
            else if (src_stride == itemsize) {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_aligned_swap@tag@_contig_to_strided_size@elsize@;
#endif
/**end repeat1**/
                }

                return &_contig_to_strided;
            }
            else {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_aligned_swap@tag@_strided_to_strided_size@elsize@;
#endif
/**end repeat1**/
                }
            }
        }

#if !NPY_USE_UNALIGNED_ACCESS
    }
    else {
        /* contiguous dst */
        if (itemsize != 0 && dst_stride == itemsize) {
            /* contiguous src */
            if (itemsize != 0 && src_stride == itemsize) {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_swap@tag@_contig_to_contig_size@elsize@;
#endif
/**end repeat1**/
                }
            }
            /* general src */
            else {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                    case @elsize@:
                        return &_swap@tag@_strided_to_contig_size@elsize@;
#endif
/**end repeat1**/
                }
            }

            return &_strided_to_contig;
        }
        /* general dst */
        else {
            /* contiguous src */
            if (itemsize != 0 && src_stride == itemsize) {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_swap@tag@_contig_to_strided_size@elsize@;
#endif
/**end repeat1**/
                }

                return &_contig_to_strided;
            }
            /* general src */
            else {
                switch (itemsize) {
/**begin repeat1
 * #elsize = 2, 4, 8, 16#
 */
#if @not_pair@ || @elsize@ > 2
                case @elsize@:
                    return &_swap@tag@_strided_to_strided_size@elsize@;
#endif
/**end repeat1**/
                }
            }
        }
    }
#endif/*!NPY_USE_UNALIGNED_ACCESS*/

    return &_swap@tag@_strided_to_strided;
}

/**end repeat**/

/*************************** COPY REFERENCES *******************************/

/* Moves references from src to dst */
static void
_strided_to_strided_move_references(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    PyObject *src_ref = NULL, *dst_ref = NULL;
    while (N > 0) {
        NPY_COPY_PYOBJECT_PTR(&src_ref, src);
        NPY_COPY_PYOBJECT_PTR(&dst_ref, dst);

        /* Release the reference in dst */
        Py_XDECREF(dst_ref);
        /* Move the reference */
        NPY_COPY_PYOBJECT_PTR(dst, &src_ref);
        /* Set the source reference to NULL */
        src_ref = NULL;
        NPY_COPY_PYOBJECT_PTR(src, &src_ref);

        src += src_stride;
        dst += dst_stride;
        --N;
    }
}

/* Copies references from src to dst */
static void
_strided_to_strided_copy_references(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    PyObject *src_ref = NULL, *dst_ref = NULL;
    while (N > 0) {
        NPY_COPY_PYOBJECT_PTR(&src_ref, src);
        NPY_COPY_PYOBJECT_PTR(&dst_ref, dst);

        /* Release the reference in dst */
        Py_XDECREF(dst_ref);
        /* Copy the reference */
        NPY_COPY_PYOBJECT_PTR(dst, &src_ref);
        /* Claim the reference */
        Py_XINCREF(src_ref);

        src += src_stride;
        dst += dst_stride;
        --N;
    }
}

/************************** ZERO-PADDED COPY ******************************/

/* Does a zero-padded copy */
typedef struct {
    void *freefunc, *copyfunc;
    npy_intp dst_itemsize;
} _strided_zero_pad_data;

/* zero-padded data copy function */
_strided_zero_pad_data *_strided_zero_pad_data_copy(
                                        _strided_zero_pad_data *data)
{
    _strided_zero_pad_data *newdata = 
            (_strided_zero_pad_data *)PyArray_malloc(
                                    sizeof(_strided_zero_pad_data));
    if (newdata == NULL) {
        return NULL;
    }

    memcpy(newdata, data, sizeof(_strided_zero_pad_data));

    return newdata;
}

/*
 * Does a strided to strided zero-padded copy for the case where
 * dst_itemsize > src_itemsize
 */
static void
_strided_to_strided_zero_pad_copy(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    _strided_zero_pad_data *d = (_strided_zero_pad_data *)data;
    npy_intp dst_itemsize = d->dst_itemsize;
    npy_intp zero_size = dst_itemsize-src_itemsize;

    while (N > 0) {
        memcpy(dst, src, src_itemsize);
        memset(dst + src_itemsize, 0, zero_size);
        src += src_stride;
        dst += dst_stride;
        --N;
    }
}

NPY_NO_EXPORT int
PyArray_GetStridedZeroPadCopyFn(npy_intp aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            npy_intp src_itemsize, npy_intp dst_itemsize,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    if (src_itemsize >= dst_itemsize) {
        /* If the sizes are different, the alignment flag isn't trustworthy */
        if (src_itemsize != dst_itemsize) {
            aligned = 0;
        }
        *outstransfer = PyArray_GetStridedCopyFn(aligned, src_stride,
                                dst_stride, dst_itemsize);
        *outtransferdata = NULL;
        return (*outstransfer == NULL) ? NPY_FAIL : NPY_SUCCEED;
    }
    else {
        _strided_zero_pad_data *d = PyArray_malloc(
                                        sizeof(_strided_zero_pad_data));
        if (d == NULL) {
            PyErr_NoMemory();
            return NPY_FAIL;
        }
        d->dst_itemsize = dst_itemsize;
        d->freefunc = &PyArray_free;
        d->copyfunc = &_strided_zero_pad_data_copy;

        *outstransfer = &_strided_to_strided_zero_pad_copy;
        *outtransferdata = d;
        return NPY_SUCCEED;
    }
}

/***************** WRAP ALIGNED CONTIGUOUS TRANFSER FUNCTION **************/

/* Wraps a transfer function + data in alignment code */
typedef struct {
    void *freefunc, *copyfunc;
    PyArray_StridedTransferFn wrapped,
                tobuffer, frombuffer;
    void *wrappeddata;
    npy_intp src_itemsize, dst_itemsize;
    char *bufferin, *bufferout;
} _align_wrap_data;

/* transfer data free function */
void _align_wrap_data_free(_align_wrap_data *data)
{
    PyArray_FreeStridedTransferData(data->wrappeddata);
    PyArray_free(data);
}

/* transfer data copy function */
_align_wrap_data *_align_wrap_data_copy(_align_wrap_data *data)
{
    _align_wrap_data *newdata;
    npy_intp basedatasize, datasize;

    /* Round up the structure size to 16-byte boundary */
    basedatasize = (sizeof(_align_wrap_data)+15)&(-0x10);
    /* Add space for two 32-element buffers */
    datasize = basedatasize + 32*data->src_itemsize + 32*data->dst_itemsize;

    /* Allocate the data, and populate it */
    newdata = (_align_wrap_data *)PyArray_malloc(datasize);
    if (newdata == NULL) {
        return NULL;
    }
    memcpy(newdata, data, basedatasize);
    newdata->bufferin = (char *)newdata + basedatasize;
    newdata->bufferout = newdata->bufferin + 32*newdata->src_itemsize;
    if (newdata->wrappeddata != NULL) {
        newdata->wrappeddata =
                        PyArray_CopyStridedTransferData(data->wrappeddata);
        if (newdata->wrappeddata == NULL) {
            PyArray_free(newdata);
            return NULL;
        }
    }

    return newdata;
}

static void
_strided_to_strided_contig_align_wrap(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    _align_wrap_data *d = (_align_wrap_data *)data;
    PyArray_StridedTransferFn wrapped = d->wrapped,
            tobuffer = d->tobuffer,
            frombuffer = d->frombuffer;
    npy_intp dst_itemsize = d->dst_itemsize;
    void *wrappeddata = d->wrappeddata;
    char *bufferin = d->bufferin, *bufferout = d->bufferout;

    for(;;) {
        if (N > 32) {
            tobuffer(bufferin, src_itemsize, src, src_stride, 32,
                                            src_itemsize, NULL);
            wrapped(bufferout, dst_itemsize, bufferin, src_itemsize, 32,
                                            src_itemsize, wrappeddata);
            frombuffer(dst, dst_stride, bufferout, dst_itemsize, 32,
                                            dst_itemsize, NULL);
            N -= 32;
            src += 32*src_stride;
            dst += 32*dst_stride;
        }
        else {
            tobuffer(bufferin, src_itemsize, src, src_stride, N,
                                            src_itemsize, NULL);
            wrapped(bufferout, dst_itemsize, bufferin, src_itemsize, N,
                                            src_itemsize, wrappeddata);
            frombuffer(dst, dst_stride, bufferout, dst_itemsize, N,
                                            dst_itemsize, NULL);
            return;
        }
    }
}

/*
 * Wraps an aligned contig to contig transfer function between either
 * copies or byte swaps to temporary buffers.
 *
 * src_itemsize/dst_itemsize - The sizes of the src and dst datatypes.
 * tobuffer - copy/swap function from src to an aligned contiguous buffer.
 *            data passed to 'tobuffer' is NULL.
 * frombuffer - copy/swap function from an aligned contiguous buffer to dst.
 *              data passed to 'frombuffer' is NULL.
 * wrapped - contig to contig transfer function being wrapped
 * wrappeddata - data for wrapped
 *
 * Returns NPY_SUCCEED or NPY_FAIL.
 */
NPY_NO_EXPORT int
PyArray_WrapAlignedContigTransferFunction(
            npy_intp src_itemsize, npy_intp dst_itemsize,
            PyArray_StridedTransferFn tobuffer,
            PyArray_StridedTransferFn frombuffer,
            PyArray_StridedTransferFn wrapped, void *wrappeddata,
            PyArray_StridedTransferFn *outstransfer,
            void **outtransferdata)
{
    _align_wrap_data *data;
    npy_intp basedatasize, datasize;

    /* Round up the structure size to 16-byte boundary */
    basedatasize = (sizeof(_align_wrap_data)+15)&(-0x10);
    /* Add space for two 32-element buffers */
    datasize = basedatasize + 32*src_itemsize + 32*dst_itemsize;

    /* Allocate the data, and populate it */
    data = (_align_wrap_data *)PyArray_malloc(datasize);
    if (data == NULL) {
        PyErr_NoMemory();
        return NPY_FAIL;
    }
    data->freefunc = (void *)&_align_wrap_data_free;
    data->copyfunc = (void *)&_align_wrap_data_copy;
    data->tobuffer = tobuffer;
    data->frombuffer = frombuffer;
    data->wrapped = wrapped;
    data->wrappeddata = wrappeddata;
    data->src_itemsize = src_itemsize;
    data->dst_itemsize = dst_itemsize;
    data->bufferin = (char *)data + basedatasize;
    data->bufferout = data->bufferin + 32*src_itemsize;

    /* Set the function and data */
    *outstransfer = &_strided_to_strided_contig_align_wrap;
    *outtransferdata = data;

    return NPY_SUCCEED;
}

/*************************** DTYPE CAST FUNCTIONS *************************/

/* Does a simple aligned cast */
typedef struct {
    void *freefunc, *copyfunc;
    PyArray_VectorUnaryFunc *castfunc;
    PyArrayObject *aip, *aop;
} _strided_cast_data;

/* strided cast data free function */
void _strided_cast_data_free(_strided_cast_data *data)
{
    Py_DECREF(data->aip);
    Py_DECREF(data->aop);
    PyArray_free(data);
}

/* strided cast data copy function */
_strided_cast_data *_strided_cast_data_copy(_strided_cast_data *data)
{
    _strided_cast_data *newdata = 
            (_strided_cast_data *)PyArray_malloc(sizeof(_strided_cast_data));
    if (newdata == NULL) {
        return NULL;
    }

    memcpy(newdata, data, sizeof(_strided_cast_data));
    Py_INCREF(newdata->aip);
    Py_INCREF(newdata->aop);

    return newdata;
}

static void
_aligned_strided_to_strided_cast(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    _strided_cast_data *d = (_strided_cast_data *)data;
    PyArray_VectorUnaryFunc *castfunc = d->castfunc;
    PyArrayObject *aip = d->aip, *aop = d->aop;

    while (N > 0) {
        castfunc(src, dst, 1, aip, aop);
        dst += dst_stride;
        src += src_stride;
        --N;
    }
}

static void
_aligned_contig_to_contig_cast(char *dst, npy_intp NPY_UNUSED(dst_stride),
                        char *src, npy_intp NPY_UNUSED(src_stride),
                        npy_intp N, npy_intp NPY_UNUSED(itemsize),
                        void *data)
{
    _strided_cast_data *d = (_strided_cast_data *)data;
    PyArray_VectorUnaryFunc *castfunc = d->castfunc;
    PyArrayObject *aip = d->aip, *aop = d->aop;

    castfunc(src, dst, N, aip, aop);
}

static int
get_cast_transfer_function(int aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,
                            int move_references,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    _strided_cast_data *data;
    PyArray_VectorUnaryFunc *castfunc;
    npy_intp shape = 1, src_itemsize = src_dtype->elsize,
            dst_itemsize = dst_dtype->elsize;

    /* Get the cast function */
    castfunc = PyArray_GetCastFunc(src_dtype, dst_dtype->type_num);
    if (!castfunc) {
        *outstransfer = NULL;
        *outtransferdata = NULL;
        return NPY_FAIL;
    }

    /* Allocate the data for the casting */
    data = (_strided_cast_data *)PyArray_malloc(sizeof(_strided_cast_data));
    if (data == NULL) {
        PyErr_NoMemory();
        *outstransfer = NULL;
        *outtransferdata = NULL;
        return NPY_FAIL;
    }
    data->freefunc = (void*)&_strided_cast_data_free;
    data->copyfunc = (void*)&_strided_cast_data_copy;
    data->castfunc = castfunc;
    Py_INCREF(src_dtype);
    data->aip = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type, src_dtype,
                            1, &shape, NULL, NULL, 0, NULL);
    if (data->aip == NULL) {
        PyArray_free(data);
        return NPY_FAIL;
    }
    Py_INCREF(dst_dtype);
    data->aop = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type, dst_dtype,
                            1, &shape, NULL, NULL, 0, NULL);
    if (data->aop == NULL) {
        Py_DECREF(data->aip);
        PyArray_free(data);
        return NPY_FAIL;
    }


    /* If it's aligned and all native byte order, we're all done */
    if (aligned && PyArray_ISNBO(src_dtype->byteorder) &&
                   PyArray_ISNBO(dst_dtype->byteorder)) {
        /* Choose the contiguous cast if we can */
        if (src_stride == src_itemsize && dst_stride == dst_itemsize) {
            *outstransfer = _aligned_contig_to_contig_cast;
        }
        else {
            *outstransfer = _aligned_strided_to_strided_cast;
        }
        *outtransferdata = data;

        return NPY_SUCCEED;
    }
    /* Otherwise, we have to copy and/or swap to aligned temporaries */
    else {
        PyArray_StridedTransferFn tobuffer, frombuffer, casttransfer;

        /* Get the copy/swap operation from src */
        if (src_itemsize == 1 || PyArray_ISNBO(src_dtype->byteorder)) {
            tobuffer = PyArray_GetStridedCopyFn(aligned,
                                        src_stride, src_itemsize,
                                        src_itemsize);
        }
        /* If it's not complex, one swap */
        else if(src_dtype->kind != 'c') {
            tobuffer = PyArray_GetStridedCopySwapFn(aligned,
                                        src_stride, src_itemsize,
                                        src_itemsize);
        }
        /* If not complex, a paired swap */
        else {
            tobuffer = PyArray_GetStridedCopySwapPairFn(aligned,
                                        src_stride, src_itemsize,
                                        src_itemsize);
        }

        /* Get the copy/swap operation to dst */
        if (dst_itemsize == 1 || PyArray_ISNBO(dst_dtype->byteorder)) {
            frombuffer = PyArray_GetStridedCopyFn(aligned,
                                        dst_itemsize, dst_stride,
                                        dst_itemsize);
        }
        /* If it's not complex, one swap */
        else if(dst_dtype->kind != 'c') {
            frombuffer = PyArray_GetStridedCopySwapFn(aligned,
                                        dst_itemsize, dst_stride,
                                        dst_itemsize);
        }
        /* If not complex, a paired swap */
        else {
            frombuffer = PyArray_GetStridedCopySwapPairFn(aligned,
                                        dst_itemsize, dst_stride,
                                        dst_itemsize);
        }

        if (frombuffer == NULL || tobuffer == NULL) {
            PyArray_FreeStridedTransferData(data);
            return NPY_FAIL;
        }

        /* Use the aligned contiguous cast */
        casttransfer = &_aligned_contig_to_contig_cast;

        /* Wrap it all up in a new transfer function + data */
        if (PyArray_WrapAlignedContigTransferFunction(
                            src_itemsize, dst_itemsize,
                            tobuffer, frombuffer,
                            casttransfer, data,
                            outstransfer, outtransferdata) != NPY_SUCCEED) {
            PyArray_FreeStridedTransferData(data);
            return NPY_FAIL;
        }

        return NPY_SUCCEED;
    }
}

/**************************** COPY 1 TO N CONTIGUOUS ************************/

/* Copies 1 element to N contiguous elements */
typedef struct {
    void *freefunc, *copyfunc;
    PyArray_StridedTransferFn stransfer;
    void *data;
    npy_intp N, dst_itemsize;
    /* If this is non-NULL the source type has references needing a decref */
    PyArray_Descr *src_dtype;
} _one_to_n_data;

/* transfer data free function */
void _one_to_n_data_free(_one_to_n_data *data)
{
    PyArray_FreeStridedTransferData(data->data);
    Py_XDECREF(data->src_dtype);
    PyArray_free(data);
}

/* transfer data copy function */
_one_to_n_data *_one_to_n_data_copy(_one_to_n_data *data)
{
    _one_to_n_data *newdata;

    /* Allocate the data, and populate it */
    newdata = (_one_to_n_data *)PyArray_malloc(sizeof(_one_to_n_data));
    if (newdata == NULL) {
        return NULL;
    }
    memcpy(newdata, data, sizeof(_one_to_n_data));
    newdata->data = PyArray_CopyStridedTransferData(data->data);
    if (newdata->data == NULL) {
        PyArray_free(newdata);
        return NULL;
    }
    Py_XINCREF(newdata->src_dtype);

    return newdata;
}

static void
_strided_to_strided_one_to_n(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    _one_to_n_data *d = (_one_to_n_data *)data;
    PyArray_Descr *src_dtype = d->src_dtype;
    PyArray_StridedTransferFn subtransfer = d->stransfer;
    void *subdata = d->data;
    npy_intp subN = d->N, dst_itemsize = d->dst_itemsize;

    if (src_dtype == NULL) {
        while (N > 0) {
            subtransfer(dst, dst_itemsize,
                        src, 0,
                        subN, src_itemsize,
                        subdata);

            src += src_stride;
            dst += dst_stride;
            --N;
        }
    }
    else {
        while (N > 0) {
            subtransfer(dst, dst_itemsize,
                        src, 0,
                        subN, src_itemsize,
                        subdata);

            PyArray_Item_XDECREF(src, src_dtype);

            src += src_stride;
            dst += dst_stride;
            --N;
        }
    }
}

static int
get_one_to_n_transfer_function(int aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,
                            int move_references,
                            npy_intp N,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    _one_to_n_data *data;


    data = PyArray_malloc(sizeof(_one_to_n_data));
    if (data == NULL) {
        PyErr_NoMemory();
        return NPY_FAIL;
    }

    /*
     * move_references is set to 0, handled in the wrapping transfer fn,
     * src_stride is set to zero, because its 1 to N copying,
     * and dst_stride is set to contiguous, because subarrays are always
     * contiguous.
     */
    if (PyArray_GetDTypeTransferFunction(aligned,
                    0, dst_dtype->elsize,
                    src_dtype, dst_dtype,
                    0,
                    &data->stransfer, &data->data) != NPY_SUCCEED) {
        PyArray_free(data);
        return NPY_FAIL;
    }
    data->freefunc = &_one_to_n_data_free;
    data->copyfunc = &_one_to_n_data_copy;
    data->N = N;
    data->dst_itemsize = dst_dtype->elsize;
    /* If the src object will need a DECREF, set src_dtype */
    if (move_references && PyDataType_REFCHK(src_dtype)) {
        data->src_dtype = src_dtype;
        Py_INCREF(src_dtype);
    }
    else {
        data->src_dtype = NULL;
    }

    *outstransfer = &_strided_to_strided_one_to_n;
    *outtransferdata = data;

    return NPY_SUCCEED;
}

/**************************** COPY N TO N CONTIGUOUS ************************/

/* Copies N contiguous elements to N contiguous elements */
typedef struct {
    void *freefunc, *copyfunc;
    PyArray_StridedTransferFn stransfer;
    void *data;
    npy_intp N, src_itemsize, dst_itemsize;
} _n_to_n_data;

/* transfer data free function */
void _n_to_n_data_free(_n_to_n_data *data)
{
    PyArray_FreeStridedTransferData(data->data);
    PyArray_free(data);
}

/* transfer data copy function */
_n_to_n_data *_n_to_n_data_copy(_n_to_n_data *data)
{
    _n_to_n_data *newdata;

    /* Allocate the data, and populate it */
    newdata = (_n_to_n_data *)PyArray_malloc(sizeof(_n_to_n_data));
    if (newdata == NULL) {
        return NULL;
    }
    memcpy(newdata, data, sizeof(_n_to_n_data));
    newdata->data = PyArray_CopyStridedTransferData(data->data);
    if (newdata->data == NULL) {
        PyArray_free(newdata);
        return NULL;
    }

    return newdata;
}

static void
_strided_to_strided_n_to_n(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp src_itemsize,
                        void *data)
{
    _n_to_n_data *d = (_n_to_n_data *)data;
    PyArray_StridedTransferFn subtransfer = d->stransfer;
    void *subdata = d->data;
    npy_intp subN = d->N, src_subitemsize = d->src_itemsize,
                dst_subitemsize = d->dst_itemsize;

    while (N > 0) {
        subtransfer(dst, dst_subitemsize,
                    src, src_subitemsize,
                    subN, src_subitemsize,
                    subdata);

        src += src_stride;
        dst += dst_stride;
        --N;
    }
}

static void
_contig_to_contig_n_to_n(char *dst, npy_intp NPY_UNUSED(dst_stride),
                        char *src, npy_intp NPY_UNUSED(src_stride),
                        npy_intp N, npy_intp NPY_UNUSED(src_itemsize),
                        void *data)
{
    _n_to_n_data *d = (_n_to_n_data *)data;
    PyArray_StridedTransferFn subtransfer = d->stransfer;
    void *subdata = d->data;
    npy_intp subN = d->N, src_subitemsize = d->src_itemsize,
                dst_subitemsize = d->dst_itemsize;

    subtransfer(dst, dst_subitemsize,
                src, src_subitemsize,
                subN*N, src_subitemsize,
                subdata);
}

static int
get_n_to_n_transfer_function(int aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,
                            int move_references,
                            npy_intp N,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    _n_to_n_data *data;


    data = PyArray_malloc(sizeof(_n_to_n_data));
    if (data == NULL) {
        PyErr_NoMemory();
        return NPY_FAIL;
    }

    /*
     * src_stride and dst_stride are set to contiguous, because
     * subarrays are always contiguous.
     */
    if (PyArray_GetDTypeTransferFunction(aligned,
                    src_dtype->elsize, dst_dtype->elsize,
                    src_dtype, dst_dtype,
                    move_references,
                    &data->stransfer, &data->data) != NPY_SUCCEED) {
        PyArray_free(data);
        return NPY_FAIL;
    }
    data->freefunc = &_n_to_n_data_free;
    data->copyfunc = &_n_to_n_data_copy;
    data->N = N;
    data->src_itemsize = src_dtype->elsize;
    data->dst_itemsize = dst_dtype->elsize;

    /*
     * If the N subarray elements exactly fit in the strides,
     * then can do a faster contiguous transfer.
     */
    if (src_stride == N * src_dtype->elsize &&
                    dst_stride == N * dst_dtype->elsize) {
        *outstransfer = &_contig_to_contig_n_to_n;
    }
    else {
        *outstransfer = &_strided_to_strided_n_to_n;
    }
    *outtransferdata = data;

    return NPY_SUCCEED;
}

/********************** COPY WITH SUBARRAY BROADCAST ************************/

/* Copies element with subarray broadcasting */
typedef struct {
    void *freefunc, *copyfunc;
    PyArray_StridedTransferFn stransfer;
    void *data;
    npy_intp src_N, dst_N, src_itemsize, dst_itemsize;
    /* If this is non-NULL the source type has references needing a decref */
    PyArray_Descr *src_dtype;
    /* If this is non-NULL, the dest type has references needing a decref */
    PyArray_Descr *dst_dtype;
    npy_intp offsets;
} _subarray_broadcast_data;

/* transfer data free function */
void _subarray_broadcast_data_free(_subarray_broadcast_data *data)
{
    PyArray_FreeStridedTransferData(data->data);
    Py_XDECREF(data->src_dtype);
    Py_XDECREF(data->dst_dtype);
    PyArray_free(data);
}

/* transfer data copy function */
_subarray_broadcast_data *_subarray_broadcast_data_copy(
                                _subarray_broadcast_data *data)
{
    _subarray_broadcast_data *newdata;
    npy_intp dst_N = data->dst_N, structsize;

    structsize = sizeof(_subarray_broadcast_data) + dst_N*NPY_SIZEOF_INTP;

    /* Allocate the data and populate it */
    newdata = (_subarray_broadcast_data *)PyArray_malloc(structsize);
    if (newdata == NULL) {
        return NULL;
    }
    memcpy(newdata, data, structsize);
    newdata->data = PyArray_CopyStridedTransferData(data->data);
    if (newdata->data == NULL) {
        PyArray_free(newdata);
        return NULL;
    }
    Py_XINCREF(newdata->src_dtype);
    Py_XINCREF(newdata->dst_dtype);

    return newdata;
}

static void
_strided_to_strided_subarray_broadcast(char *dst, npy_intp dst_stride,
                        char *src, npy_intp src_stride,
                        npy_intp N, npy_intp NPY_UNUSED(src_itemsize),
                        void *data)
{
    _subarray_broadcast_data *d = (_subarray_broadcast_data *)data;
    PyArray_Descr *src_dtype = d->src_dtype, *dst_dtype = d->dst_dtype;
    PyArray_StridedTransferFn subtransfer = d->stransfer;
    void *subdata = d->data;
    npy_intp i, dst_subN = d->dst_N, src_subN = d->src_N,
            src_subitemsize = d->src_itemsize,
            dst_subitemsize = d->dst_itemsize;
    npy_intp *offsets = &d->offsets;

    if (src_dtype == NULL && dst_dtype == NULL) {
        while (N > 0) {
            for (i = 0; i < dst_subN; ++i) {
                if (offsets[i] != -1) {
                    subtransfer(dst + i*dst_subitemsize, dst_subitemsize,
                                src + offsets[i], src_subitemsize,
                                1, src_subitemsize,
                                subdata);
                }
                else {
                    char *tmp = dst + i*dst_subitemsize;
                    memset(tmp, 0, dst_subitemsize);
                }
            }

            src += src_stride;
            dst += dst_stride;
            --N;
        }
    }
    else {
        while (N > 0) {
            for (i = 0; i < dst_subN; ++i) {
                if (offsets[i] != -1) {
                    subtransfer(dst + i*dst_subitemsize, dst_subitemsize,
                                src + offsets[i], src_subitemsize,
                                1, src_subitemsize,
                                subdata);
                }
                else {
                    char *tmp = dst + i*dst_subitemsize;
                    if (dst_dtype) {
                        PyArray_Item_XDECREF(tmp, dst_dtype);
                    }
                    memset(tmp, 0, dst_subitemsize);
                }
            }

            for (i = 0; i < src_subN; ++i) {
                PyArray_Item_XDECREF(src + i*src_subitemsize, src_dtype);
            }

            src += src_stride;
            dst += dst_stride;
            --N;
        }
    }
}


static int
get_subarray_broadcast_transfer_function(int aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,
                            npy_intp src_size, npy_intp dst_size,
                            PyArray_Dims src_shape, PyArray_Dims dst_shape,
                            int move_references,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    _subarray_broadcast_data *data;
    npy_intp structsize, index, src_index, dst_index, i, ndim, *offsets;
    
    structsize = sizeof(_subarray_broadcast_data) + dst_size*NPY_SIZEOF_INTP;

    /* Allocate the data and populate it */
    data = (_subarray_broadcast_data *)PyArray_malloc(structsize);
    if (data == NULL) {
        PyErr_NoMemory();
        return NPY_FAIL;
    }

    /*
     * move_references is set to 0, handled in the wrapping transfer fn,
     * src_stride and dst_stride are set to contiguous, as N will always
     * be 1 when it's called.
     */
    if (PyArray_GetDTypeTransferFunction(aligned,
                    src_dtype->elsize, dst_dtype->elsize,
                    src_dtype, dst_dtype,
                    0,
                    &data->stransfer, &data->data) != NPY_SUCCEED) {
        PyArray_free(data);
        return NPY_FAIL;
    }
    data->freefunc = &_subarray_broadcast_data_free;
    data->copyfunc = &_subarray_broadcast_data_copy;
    data->src_N = src_size;
    data->dst_N = dst_size;
    data->src_itemsize = src_dtype->elsize;
    data->dst_itemsize = dst_dtype->elsize;

    /* If the src object will need a DECREF, set src_dtype */
    if (move_references && PyDataType_REFCHK(src_dtype)) {
        data->src_dtype = src_dtype;
        Py_INCREF(src_dtype);
    }
    else {
        data->src_dtype = NULL;
    }

    /* If the dst object needs a DECREF to set it to NULL, set dst_dtype */
    if (PyDataType_REFCHK(dst_dtype)) {
        data->dst_dtype = dst_dtype;
        Py_INCREF(dst_dtype);
    }
    else {
        data->dst_dtype = NULL;
    }

    /* Calculate the broadcasting and set the offsets */
    offsets = &data->offsets;
    ndim = (src_shape.len > dst_shape.len) ? src_shape.len : dst_shape.len;
    for (index = 0; index < dst_size; ++index) {
        dst_index = index;
        src_index = 0;
        for (i = ndim-1; i >= 0; --i) {
            npy_intp coord = 0, shape;

            /* Get the dst coord of this index for dimension i */
            if (i >= ndim - dst_shape.len) {
                shape = dst_shape.ptr[i-(ndim-dst_shape.len)];
                coord = dst_index % shape;
                dst_index /= shape;
            }

            /* Translate it into a src coord and update src_index */
            if (i >= ndim - src_shape.len) {
                shape = src_shape.ptr[i-(ndim-src_shape.len)];
                if (shape == 1) {
                    coord = 0;
                }
                else {
                    if (coord < shape) {
                        src_index *= shape;
                        src_index += coord;
                    }
                    else {
                        /* Out of bounds, flag with -1 */
                        src_index = -1;
                        break;
                    }
                }
            }
        }
        /* Set the offset */
        if (src_index == -1) {
            offsets[index] = -1;
        }
        else {
            offsets[index] = src_index * src_dtype->elsize;
        }
    }

    *outstransfer = &_strided_to_strided_subarray_broadcast;
    *outtransferdata = data;

    return NPY_SUCCEED;
}

/*
 * Handles subarray transfer.  To call this, at least one of the dtype's
 * subarrays must be non-NULL
 */
static int
get_subarray_transfer_function(int aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,
                            int move_references,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    PyArray_Dims src_shape = {NULL, -1}, dst_shape = {NULL, -1};
    npy_intp src_size = 1, dst_size = 1;

    /* Get the subarray shapes and sizes */
    if (src_dtype->subarray != NULL) {
       if (!(PyArray_IntpConverter(src_dtype->subarray->shape,
                                            &src_shape))) {
            PyErr_SetString(PyExc_ValueError,
                    "invalid shape in fixed-type tuple.");
            return NPY_FAIL;
        }
        src_size = PyArray_MultiplyList(src_shape.ptr, src_shape.len);
        src_dtype = src_dtype->subarray->base;
    }
    if (dst_dtype->subarray != NULL) {
       if (!(PyArray_IntpConverter(dst_dtype->subarray->shape,
                                            &dst_shape))) {
            if (src_shape.ptr != NULL) {
                PyDimMem_FREE(src_shape.ptr);
            }
            PyErr_SetString(PyExc_ValueError,
                    "invalid shape in fixed-type tuple.");
            return NPY_FAIL;
        }
        dst_size = PyArray_MultiplyList(dst_shape.ptr, dst_shape.len);
        dst_dtype = dst_dtype->subarray->base;
    }

    /*
     * Just a straight one-element copy.  If the source size isn't 1,
     * we copy the element at index 0.  If the source data type is
     * a reference and we're moving references, a DECREF for each
     * source element would also be needed, so the general case will be
     * used below
     */
    if (dst_size == 1 && (src_size == 1 ||
                          !move_references ||
                          !PyDataType_REFCHK(src_dtype))) {
        PyDimMem_FREE(src_shape.ptr);
        PyDimMem_FREE(dst_shape.ptr);

        return PyArray_GetDTypeTransferFunction(aligned,
                src_stride, dst_stride,
                dst_dtype, dst_dtype,
                move_references,
                outstransfer, outtransferdata);
    }
    /* Copy the src value to all the dst values */
    else if (src_size == 1) {
        PyDimMem_FREE(src_shape.ptr);
        PyDimMem_FREE(dst_shape.ptr);

        return get_one_to_n_transfer_function(aligned,
                        src_stride, dst_stride,
                        src_dtype, dst_dtype,
                        move_references,
                        dst_size,
                        outstransfer, outtransferdata);
    }
    /* If the shapes match exactly, do an n to n copy */
    else if (src_shape.len == dst_shape.len &&
               PyArray_CompareLists(src_shape.ptr, dst_shape.ptr,
                                                    src_shape.len)) {
        PyDimMem_FREE(src_shape.ptr);
        PyDimMem_FREE(dst_shape.ptr);

        return get_n_to_n_transfer_function(aligned,
                        src_stride, dst_stride,
                        src_dtype, dst_dtype,
                        move_references,
                        src_size,
                        outstransfer, outtransferdata);
    }
    /*
     * Copy the subarray with broadcasting, truncating, and zero-padding
     * as necessary.
     */
    else {
        int ret = get_subarray_broadcast_transfer_function(aligned,
                        src_stride, dst_stride,
                        src_dtype, dst_dtype,
                        src_size, dst_size,
                        src_shape, dst_shape,
                        move_references,
                        outstransfer, outtransferdata);

        PyDimMem_FREE(src_shape.ptr);
        PyDimMem_FREE(dst_shape.ptr);
        return ret;
    }
}

NPY_NO_EXPORT int
PyArray_GetDTypeTransferFunction(int aligned,
                            npy_intp src_stride, npy_intp dst_stride,
                            PyArray_Descr *src_dtype, PyArray_Descr *dst_dtype,
                            int move_references,
                            PyArray_StridedTransferFn *outstransfer,
                            void **outtransferdata)
{
    npy_intp src_itemsize = src_dtype->elsize,
             dst_itemsize = dst_dtype->elsize;
    int src_type_num = src_dtype->type_num,
        dst_type_num = dst_dtype->type_num;

    /* First look at the possibilities of just a copy or swap */
    if (src_itemsize == dst_itemsize && src_dtype->kind == dst_dtype->kind &&
                src_type_num < NPY_NTYPES && dst_type_num < NPY_NTYPES &&
                (src_dtype->fields == NULL || src_dtype->fields == Py_None) &&
                (dst_dtype->fields == NULL || dst_dtype->fields == Py_None) &&
                src_dtype->subarray == NULL && dst_dtype->subarray == NULL) {
        /* The special types, which have no byte-order */
        switch (src_type_num) {
            case NPY_VOID:
            case NPY_STRING:
            case NPY_UNICODE:
                *outstransfer = PyArray_GetStridedCopyFn(0,
                                    src_stride, dst_stride,
                                    src_itemsize);
                *outtransferdata = NULL;
                return NPY_SUCCEED;
            case NPY_OBJECT:
                if (move_references) {
                    *outstransfer = &_strided_to_strided_move_references;
                    *outtransferdata = NULL;
                }
                else {
                    *outstransfer = &_strided_to_strided_copy_references;
                    *outtransferdata = NULL;
                }
                return NPY_SUCCEED;
        }

        /* This is a straight copy */
        if (src_itemsize == 1 || PyArray_ISNBO(src_dtype->byteorder) ==
                                 PyArray_ISNBO(dst_dtype->byteorder)) {
            *outstransfer = PyArray_GetStridedCopyFn(aligned,
                                        src_stride, dst_stride,
                                        src_itemsize);
            *outtransferdata = NULL;
            return (*outstransfer == NULL) ? NPY_FAIL : NPY_SUCCEED;
        }
        /* This is a straight copy + byte swap */
        else if (!PyTypeNum_ISCOMPLEX(src_type_num)) {
            *outstransfer = PyArray_GetStridedCopySwapFn(aligned,
                                        src_stride, dst_stride,
                                        src_itemsize);
            *outtransferdata = NULL;
            return (*outstransfer == NULL) ? NPY_FAIL : NPY_SUCCEED;
        }
        /* This is a straight copy + element pair byte swap */
        else {
            *outstransfer = PyArray_GetStridedCopySwapPairFn(aligned,
                                        src_stride, dst_stride,
                                        src_itemsize);
            *outtransferdata = NULL;
            return (*outstransfer == NULL) ? NPY_FAIL : NPY_SUCCEED;
        }
    }

    /* Handle subarrays */
    if (src_dtype->subarray != NULL || dst_dtype->subarray != NULL) {
        return get_subarray_transfer_function(aligned,
                        src_stride, dst_stride,
                        src_dtype, dst_dtype,
                        move_references,
                        outstransfer, outtransferdata);
    }

    /* TODO: Handle fields here */

    /* Check for different-sized strings or unicode */
    if (src_type_num == dst_type_num) switch (src_type_num) {
        case NPY_STRING:
        case NPY_UNICODE:
        // case NPY_VOID:
            return PyArray_GetStridedZeroPadCopyFn(0,
                                    src_stride, dst_stride,
                                    src_dtype->elsize, dst_dtype->elsize,
                                    outstransfer, outtransferdata);
    }

    /* Check whether a simple cast and some swaps will suffice */
    if (src_type_num < NPY_NTYPES && dst_type_num < NPY_NTYPES) {
        return get_cast_transfer_function(aligned,
                        src_stride, dst_stride,
                        src_dtype, dst_dtype,
                        move_references,
                        outstransfer, outtransferdata);
    }

    /* TODO check for fields & subarrays */
    printf("\n");
    PyObject_Print((PyObject *)src_dtype, stdout, 0);
    printf(" -> ");
    PyObject_Print((PyObject *)dst_dtype, stdout, 0);
    printf("\n");

    /* TODO: write the more complicated transfer code! */
    *outstransfer = NULL;
    *outtransferdata = NULL;
    PyErr_SetString(PyExc_RuntimeError,
            "General transfer function support has not been written yet");
    return NPY_FAIL;
}

typedef void (*_npy_stridedtransfer_dealloc)(void *);
NPY_NO_EXPORT void
PyArray_FreeStridedTransferData(void *transferdata)
{
    if (transferdata != NULL) {
        _npy_stridedtransfer_dealloc dealloc =
                        *((_npy_stridedtransfer_dealloc *)transferdata);
        dealloc(transferdata);
    }
}

typedef void *(*_npy_stridedtransfer_copy)(void *);
NPY_NO_EXPORT void *
PyArray_CopyStridedTransferData(void *transferdata)
{
    if (transferdata != NULL) {
        _npy_stridedtransfer_copy copy =
                        *((_npy_stridedtransfer_copy *)transferdata + 1);
        return copy(transferdata);
    }

    return NULL;
}



NPY_NO_EXPORT npy_intp
PyArray_TransferNDimToStrided(npy_intp ndim,
                char *dst, npy_intp dst_stride,
                char *src, npy_intp *src_strides, npy_intp src_strides_inc,
                npy_intp *coords, npy_intp coords_inc,
                npy_intp *shape, npy_intp shape_inc,
                npy_intp count, npy_intp src_itemsize,
                PyArray_StridedTransferFn stransfer,
                void *data)
{
    npy_intp i, M, N, coord0, shape0, src_stride0, coord1, shape1, src_stride1;

    /* Finish off dimension 0 */
    coord0 = coords[0];
    shape0 = shape[0];
    src_stride0 = src_strides[0];
    N = shape0 - coord0;
    if (N >= count) {
        stransfer(dst, dst_stride, src, src_stride0, count, src_itemsize, data);
        return 0;
    }
    stransfer(dst, dst_stride, src, src_stride0, N, src_itemsize, data);
    count -= N;

    /* If it's 1-dimensional, there's no more to copy */
    if (ndim == 1) {
        return count;
    }

    /* Adjust the src and dst pointers */
    coord1 = (coords + coords_inc)[0];
    shape1 = (shape + shape_inc)[0];
    src_stride1 = (src_strides + src_strides_inc)[0];
    src = src - coord0*src_stride0 + src_stride1;
    dst += N*dst_stride;

    /* Finish off dimension 1 */
    M = (shape1 - coord1 - 1);
    N = shape0*M;
    for (i = 0; i < M; ++i) {
        if (shape0 >= count) {
            stransfer(dst, dst_stride, src, src_stride0,
                        count, src_itemsize, data);
            return 0;
        }
        else {
            stransfer(dst, dst_stride, src, src_stride0,
                        shape0, src_itemsize, data);
        }
        count -= shape0;
        src += src_stride1;
        dst += shape0*dst_stride;
    }

    /* If it's 2-dimensional, there's no more to copy */
    if (ndim == 2) {
        return count;
    }

    /* General-case loop for everything else */
    else {
        /* Iteration structure for dimensions 2 and up */
        struct {
            npy_intp coord, shape, src_stride;
        } it[NPY_MAXDIMS];

        /* Copy the coordinates and shape */
        coords += 2*coords_inc;
        shape += 2*shape_inc;
        src_strides += 2*src_strides_inc;
        for (i = 0; i < ndim-2; ++i) {
            it[i].coord = coords[0];
            it[i].shape = shape[0];
            it[i].src_stride = src_strides[0];
            coords += coords_inc;
            shape += shape_inc;
            src_strides += src_strides_inc;
        }

        for (;;) {
            /* Adjust the src pointer from the dimension 0 and 1 loop */
            src = src - shape1*src_stride1;

            /* Increment to the next coordinate */
            for (i = 0; i < ndim-2; ++i) {
                src += it[i].src_stride;
                if (++it[i].coord >= it[i].shape) {
                    it[i].coord = 0;
                    src -= it[i].src_stride*it[i].shape;
                }
                else {
                    break;
                }
            }
            /* If the last dimension rolled over, we're done */
            if (i == ndim-2) {
                return count;
            }

            /* A loop for dimensions 0 and 1 */
            for (i = 0; i < shape1; ++i) {
                if (shape0 >= count) {
                    stransfer(dst, dst_stride, src, src_stride0,
                                count, src_itemsize, data);
                    return 0;
                }
                else {
                    stransfer(dst, dst_stride, src, src_stride0,
                                shape0, src_itemsize, data);
                }
                count -= shape0;
                src += src_stride1;
                dst += shape0*dst_stride;
            }
        }
    }
}

NPY_NO_EXPORT npy_intp
PyArray_TransferStridedToNDim(npy_intp ndim,
                char *dst, npy_intp *dst_strides, npy_intp dst_strides_inc,
                char *src, npy_intp src_stride,
                npy_intp *coords, npy_intp coords_inc,
                npy_intp *shape, npy_intp shape_inc,
                npy_intp count, npy_intp src_itemsize,
                PyArray_StridedTransferFn stransfer,
                void *data)
{
    npy_intp i, M, N, coord0, shape0, dst_stride0, coord1, shape1, dst_stride1;

    /* Finish off dimension 0 */
    coord0 = coords[0];
    shape0 = shape[0];
    dst_stride0 = dst_strides[0];
    N = shape0 - coord0;
    if (N >= count) {
        stransfer(dst, dst_stride0, src, src_stride, count, src_itemsize, data);
        return 0;
    }
    stransfer(dst, dst_stride0, src, src_stride, N, src_itemsize, data);
    count -= N;

    /* If it's 1-dimensional, there's no more to copy */
    if (ndim == 1) {
        return count;
    }

    /* Adjust the src and dst pointers */
    coord1 = (coords + coords_inc)[0];
    shape1 = (shape + shape_inc)[0];
    dst_stride1 = (dst_strides + dst_strides_inc)[0];
    dst = dst - coord0*dst_stride0 + dst_stride1;
    src += N*src_stride;

    /* Finish off dimension 1 */
    M = (shape1 - coord1 - 1);
    N = shape0*M;
    for (i = 0; i < M; ++i) {
        if (shape0 >= count) {
            stransfer(dst, dst_stride0, src, src_stride,
                        count, src_itemsize, data);
            return 0;
        }
        else {
            stransfer(dst, dst_stride0, src, src_stride,
                        shape0, src_itemsize, data);
        }
        count -= shape0;
        dst += dst_stride1;
        src += shape0*src_stride;
    }

    /* If it's 2-dimensional, there's no more to copy */
    if (ndim == 2) {
        return count;
    }

    /* General-case loop for everything else */
    else {
        /* Iteration structure for dimensions 2 and up */
        struct {
            npy_intp coord, shape, dst_stride;
        } it[NPY_MAXDIMS];

        /* Copy the coordinates and shape */
        coords += 2*coords_inc;
        shape += 2*shape_inc;
        dst_strides += 2*dst_strides_inc;
        for (i = 0; i < ndim-2; ++i) {
            it[i].coord = coords[0];
            it[i].shape = shape[0];
            it[i].dst_stride = dst_strides[0];
            coords += coords_inc;
            shape += shape_inc;
            dst_strides += dst_strides_inc;
        }

        for (;;) {
            /* Adjust the dst pointer from the dimension 0 and 1 loop */
            dst = dst - shape1*dst_stride1;

            /* Increment to the next coordinate */
            for (i = 0; i < ndim-2; ++i) {
                dst += it[i].dst_stride;
                if (++it[i].coord >= it[i].shape) {
                    it[i].coord = 0;
                    dst -= it[i].dst_stride*it[i].shape;
                }
                else {
                    break;
                }
            }
            /* If the last dimension rolled over, we're done */
            if (i == ndim-2) {
                return count;
            }

            /* A loop for dimensions 0 and 1 */
            for (i = 0; i < shape1; ++i) {
                if (shape0 >= count) {
                    stransfer(dst, dst_stride0, src, src_stride,
                                count, src_itemsize, data);
                    return 0;
                }
                else {
                    stransfer(dst, dst_stride0, src, src_stride,
                                shape0, src_itemsize, data);
                }
                count -= shape0;
                dst += dst_stride1;
                src += shape0*src_stride;
            }
        }
    }
}
